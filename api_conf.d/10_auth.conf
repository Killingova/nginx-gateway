# =========================================================
# 10_auth.conf (server-level snippet)
# Rolle:
# - /auth/* -> auth_service
# - ABER: Auth-Module hängen am Prefix /auth (Fastify)
# - Ausnahme: /auth/healthz ist Gateway-Alias auf upstream /healthz
# =========================================================

# Internal Guard: Tenant-Existenz via auth-service
location = /_guard/tenant {
  internal;

  proxy_connect_timeout 2s;
  proxy_read_timeout    2s;
  proxy_send_timeout    2s;

  proxy_pass_request_body off;
  proxy_set_header Content-Length "";

  proxy_set_header X-Tenant-Id $tenant_from_header;

  proxy_pass http://$auth_upstream_host/internal/tenants/$tenant_from_header;
}

# Alias: Gateway /auth/healthz -> Upstream /healthz
location = /auth/healthz {
  if ($request_method !~ ^(GET|OPTIONS)$) {
    return 405 '{"status":405,"error":{"code":"METHOD_NOT_ALLOWED","message":"Method not allowed."},"request_id":"$gateway_request_id"}\n';
  }
  limit_req zone=auth_limit burst=10 nodelay;
  limit_req zone=auth_tenant_limit burst=10 nodelay;

  proxy_http_version 1.1;
  proxy_set_header Connection "";

  proxy_connect_timeout 5s;
  proxy_send_timeout    60s;
  proxy_read_timeout    60s;

  proxy_pass http://$auth_upstream_host/healthz;
}

# /auth/login bekommt route-aware tenant+ip bucket (isoliert pro tenant/ip/route)
location = /auth/login {
  if ($request_method !~ ^(POST|OPTIONS)$) {
    return 405 '{"status":405,"error":{"code":"METHOD_NOT_ALLOWED","message":"Method not allowed."},"request_id":"$gateway_request_id"}\n';
  }
  limit_req zone=auth_tenant_limit burst=10 nodelay;

  auth_request /_guard/tenant;

  error_page 403 404 = @tenant_unknown;
  error_page 500 502 503 504 = @tenant_registry_down;

  proxy_http_version 1.1;
  proxy_set_header Connection "";

  proxy_connect_timeout 5s;
  proxy_send_timeout    60s;
  proxy_read_timeout    60s;

  proxy_set_header Host $host;
  proxy_set_header X-Request-Id $gateway_request_id;
  proxy_set_header X-Tenant-Id $tenant_from_header;

  proxy_pass http://$auth_upstream_host;
}

# /auth/refresh bekommt route-aware tenant+ip bucket (isoliert pro tenant/ip/route)
location = /auth/refresh {
  if ($request_method !~ ^(POST|OPTIONS)$) {
    return 405 '{"status":405,"error":{"code":"METHOD_NOT_ALLOWED","message":"Method not allowed."},"request_id":"$gateway_request_id"}\n';
  }
  limit_req zone=auth_tenant_limit burst=10 nodelay;

  auth_request /_guard/tenant;

  error_page 403 404 = @tenant_unknown;
  error_page 500 502 503 504 = @tenant_registry_down;

  proxy_http_version 1.1;
  proxy_set_header Connection "";

  proxy_connect_timeout 5s;
  proxy_send_timeout    60s;
  proxy_read_timeout    60s;

  proxy_set_header Host $host;
  proxy_set_header X-Request-Id $gateway_request_id;
  proxy_set_header X-Tenant-Id $tenant_from_header;

  proxy_pass http://$auth_upstream_host;
}

# Geschuetzte Auth-Routen (Edge AuthZ fail-closed):
# - /auth/me
# - /auth/logout
# - /auth/sessions*
location ~ ^/auth/(me|logout|sessions(?:/.*)?)$ {
  limit_req zone=auth_limit burst=10 nodelay;
  limit_req zone=auth_tenant_limit burst=10 nodelay;
  if ($request_method !~ ^(GET|POST|DELETE|OPTIONS)$) {
    return 405 '{"status":405,"error":{"code":"METHOD_NOT_ALLOWED","message":"Method not allowed."},"request_id":"$gateway_request_id"}\n';
  }

  set $required_scope "";
  set $required_role "";
  set $authz_header_forward $http_authorization;
  set $tenant_header_forward $tenant_from_header;

  auth_request /_auth_verify;
  error_page 401 = @gw_err_401;
  error_page 403 = @gw_err_403;
  error_page 500 502 503 504 = @auth_verify_unavailable;
  auth_request_set $auth_user_id   $upstream_http_x_user_id;
  auth_request_set $auth_tenant_id $upstream_http_x_tenant_id;

  proxy_http_version 1.1;
  proxy_set_header Connection "";

  proxy_connect_timeout 5s;
  proxy_send_timeout    60s;
  proxy_read_timeout    60s;

  proxy_set_header Host $host;
  proxy_set_header Authorization $http_authorization;
  proxy_set_header X-Request-Id $gateway_request_id;
  proxy_set_header X-Tenant-Id $auth_tenant_id;
  proxy_set_header X-User-Id $auth_user_id;

  proxy_pass http://$auth_upstream_host;
}

# Public/Auth Utility Routen (KEIN rewrite!)
location /auth/ {
  limit_req zone=auth_limit burst=10 nodelay;
  limit_req zone=auth_tenant_limit burst=10 nodelay;
  if ($request_method !~ ^(GET|POST|OPTIONS)$) {
    return 405 '{"status":405,"error":{"code":"METHOD_NOT_ALLOWED","message":"Method not allowed."},"request_id":"$gateway_request_id"}\n';
  }

  # Missing-Header (400) bleibt global via $tenant_reject_missing
  auth_request /_guard/tenant;

  # Guard-Fehler auf eigene Responses mappen
  error_page 403 404 = @tenant_unknown;
  error_page 500 502 503 504 = @tenant_registry_down;

  proxy_http_version 1.1;
  proxy_set_header Connection "";

  proxy_connect_timeout 5s;
  proxy_send_timeout    60s;
  proxy_read_timeout    60s;

  # Header explizit setzen (zusätzlich zu server-level defaults)
  proxy_set_header Host $host;
  proxy_set_header X-Request-Id $gateway_request_id;
  # UUID-validierter Tenant-Header aus dem Gateway-Map
  proxy_set_header X-Tenant-Id $tenant_from_header;

  proxy_pass http://$auth_upstream_host;
}

location @tenant_unknown {
  default_type application/json;
  return 403 '{"status":403,"error":{"code":"TENANT_UNKNOWN","message":"Unknown tenant."},"request_id":"$gateway_request_id"}\n';
}

location @tenant_registry_down {
  default_type application/json;
  return 503 '{"status":503,"error":{"code":"TENANT_REGISTRY_UNAVAILABLE","message":"Tenant registry unavailable."},"request_id":"$gateway_request_id"}\n';
}
